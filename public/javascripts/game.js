// Generated by CoffeeScript 1.6.3
(function() {
  var add_critical_message, critical_hit, critical_message, d12, d6, damage_animation, damage_to, destroy, drawMech, mech, _da_phase;

  d6 = function() {
    return Math.floor(Math.random() * 6 + 1);
  };

  d12 = function() {
    return Math.floor(Math.random() * 12 + 1);
  };

  WEAPONS.forEach(function(weapon) {
    return $('.weapons .' + weapon.type).append(Templates.weapon(weapon));
  });

  mech = new MECHS.VulcanVL2T;

  drawMech = function() {
    var context, part, part_info, _results;
    $('.parts').empty();
    _results = [];
    for (part in PARTS) {
      part_info = PARTS[part];
      context = {
        name: part,
        armor: mech['ARMOR_' + part],
        structure: mech['STRUCTURE_' + part],
        armor_remaining: mech['armor_' + part],
        structure_remaining: mech['structure_' + part]
      };
      _results.push($('.parts').append(Templates.part(context)));
    }
    return _results;
  };

  drawMech();

  $('.sides .side').click(function() {
    $('.sides .side').removeClass('active');
    return $(this).addClass('active');
  });

  $('.weapon button').click(function() {
    var $count, delta;
    if ($(this).text() === '-') {
      delta = -1;
    } else {
      delta = 1;
    }
    $count = $(this).parents('.weapon').find('.count');
    return $count.text(Math.max(0, delta + parseInt($count.text())));
  });

  add_critical_message = function() {
    if (critical_message) {
      critical_message += "<br>";
    }
    return critical_message += 'critical!';
  };

  critical_hit = function(part) {
    var candidates, hit, i, slot;
    add_critical_message('critical!');
    console.log('critical on ', part, '!!!');
    candidates = [];
    i = 1;
    while (i <= 12) {
      slot = mech['CRIT_' + part + '_' + i];
      if (slot && !mech['destroyed_' + part + '_' + i]) {
        candidates.append({
          row: i,
          slot: slot
        });
      }
      i += 1;
    }
    if (candidates.length) {
      hit = candidates[Math.floor(Math.random() * candidates.length)];
      add_critical_message('hit ' + part + ' : ' + hit.slot);
      return mech['destroyed_' + part + '_' + hit.i] = true;
    } else if (PARTS[part].flows_to) {
      return critical_hit(PARTS[part].flows_to);
    }
  };

  destroy = function() {
    mech.destroyed = true;
    return console.log("DESTROYED!!!");
  };

  _da_phase = {};

  damage_animation = function($part, damage, critical) {
    var $damage, loc, part;
    if (critical == null) {
      critical = '';
    }
    loc = $part.offset();
    $('body').append($damage = $("<div class='damage-alert'><div class='num'>" + damage + "</div><div class='crit'>" + critical + "</div></div!>"));
    part = $part.get(0).className;
    if (_da_phase[part] == null) {
      _da_phase[part] = 0;
    }
    _da_phase[part] += 2;
    $damage.css({
      left: loc.left + Math.sin(_da_phase[part]) * 15,
      top: loc.top + Math.cos(_da_phase[part]) * 15
    });
    return setTimeout(function() {
      return $damage.remove();
    }, 3000);
  };

  critical_message = '';

  damage_to = function(part, damage, force_critical) {
    var $part, armor, flows_to, orig_structure, roll, structure;
    if (force_critical == null) {
      force_critical = false;
    }
    console.log(part, 'hit with', damage, 'damage!');
    $part = $('.' + part);
    critical_message = '';
    armor = mech['armor_' + part];
    orig_structure = structure = mech['structure_' + part];
    if (force_critical) {
      critical_hit(part);
    }
    armor -= damage;
    if (armor < 0) {
      part = part.replace('_REAR', '');
      $part = $('.' + part);
      structure = mech['structure_' + part];
      if (structure) {
        roll = d6() + d6();
        console.log('critical roll', roll);
        if (roll >= 8) {
          critical_hit(part);
        }
        if (roll >= 10) {
          critical_hit(part);
        }
        if (roll === 12) {
          if (part === "HEAD") {
            return destroy();
          } else if (part === "ARM" || part === 'LEG') {
            add_critical_message(part + ' blown off!');
            structure = 0;
          } else {
            critical_hit(part);
          }
        }
      }
      structure += armor;
      console.log('hit structure down to', structure);
      armor = 0;
      if (structure < 1) {
        flows_to = PARTS[part].flows_to;
        if (flows_to === "DEATH") {
          destroy();
        } else {
          if (structure < 0) {
            if (orig_structure > 0) {
              console.log(part, 'blown off!');
            }
            console.log(-structure, 'damaged flows to', flows_to);
            damage_to(flows_to, -structure);
          }
          structure = 0;
        }
      }
    }
    console.log(critical_message, 'was the message');
    damage_animation($part, damage, critical_message);
    mech['structure_' + part] = structure;
    return mech['armor_' + part] = armor;
  };

  $('.fire').click(function() {
    var $weapons;
    $weapons = $('.count').filter(function() {
      return parseInt($(this).text()) > 0;
    }).parent();
    $weapons.each(function() {
      var count, damage, location, roll, side, _results;
      count = parseInt($(this).find('.count').text());
      _results = [];
      while (count) {
        count -= 1;
        side = $('.sides .active').text();
        roll = d6() + d6();
        location = RANGED_HIT_LOCATION[side][roll + ''];
        damage = parseInt($(this).find('.damage').text() || $(this).find('.damage').val());
        _results.push(damage_to(location, damage, roll === 2));
      }
      return _results;
    });
    $('.count').text(0);
    return drawMech();
  });

}).call(this);
