// Generated by CoffeeScript 1.6.3
(function() {
  var active_mech, active_player, add_critical_message, critical_hit, critical_message, d12, d6, damage_animation, damage_to, destroy, drawMech, drawMechs, drawPlayerForces, drawPlayers, drawWeapons, players, routeMech, routePlayer, _da_phase, _mech;

  d6 = function() {
    return Math.floor(Math.random() * 6 + 1);
  };

  d12 = function() {
    return Math.floor(Math.random() * 12 + 1);
  };

  players = (JSON.parse(localStorage.getItem('players'))) || [];

  drawWeapons = function() {
    return WEAPONS.forEach(function(weapon) {
      return $('.weapons .' + weapon.type).append(Templates.weapon(weapon));
    });
  };

  drawPlayers = function() {
    $('.players ul').empty();
    return players.forEach(function(player) {
      var $li;
      $li = $(Templates.player(player));
      if (player === active_player) {
        $li.addClass('active');
      }
      return $('.players ul').append($li);
    });
  };

  drawMechs = function() {
    $('.mechs ul').empty();
    return players.forEach(function(player) {
      return $('.players ul').append(Templates.player(player));
    });
  };

  routePlayer = function(player) {
    player = _.findWhere(players, {
      name: player
    });
    return window.location.hash = player.name;
  };

  routeMech = function(mech) {
    mech = _.findWhere(active_player.mechs, {
      name: mech
    });
    return window.location.hash = active_player.name + '/' + mech.name;
  };

  drawPlayerForces = function() {
    $('.mechs ul').empty();
    return active_player.mechs.forEach(function(mech) {
      var $li;
      $li = $(Templates.mech(mech));
      if (active_mech === mech) {
        $li.addClass('active');
      }
      return $('.mechs ul').append($li);
    });
  };

  $('.players .new button').click(function() {
    players.push({
      name: $('.players .new [name="name"]').val(),
      mechs: []
    });
    localStorage.setItem('players', JSON.stringify(players));
    return drawPlayers();
  });

  $('.mechs .new button').click(function() {
    active_player.mechs.push({
      name: $('.mechs .new [name="name"]').val(),
      type: $('.mechs .new select').val()
    });
    localStorage.setItem('players', JSON.stringify(players));
    return drawPlayerForces();
  });

  $('.players').on('click', 'li', function(e) {
    return routePlayer($(e.target).text());
  });

  $('.mechs').on('click', 'li', function(e) {
    return routeMech($(e.target).text());
  });

  drawMech = function() {
    var context, part, part_info, _results;
    $('.parts').empty().show();
    _results = [];
    for (part in PARTS) {
      part_info = PARTS[part];
      context = {
        name: part,
        armor: _mech['ARMOR_' + part],
        structure: _mech['STRUCTURE_' + part],
        armor_remaining: _mech['armor_' + part],
        structure_remaining: _mech['structure_' + part]
      };
      _results.push($('.parts').append(Templates.part(context)));
    }
    return _results;
  };

  $('.sides .side').click(function() {
    $('.sides .side').removeClass('active');
    return $(this).addClass('active');
  });

  $('.weapon button').click(function() {
    var $count, delta;
    if ($(this).text() === '-') {
      delta = -1;
    } else {
      delta = 1;
    }
    $count = $(this).parents('.weapon').find('.count');
    return $count.text(Math.max(0, delta + parseInt($count.text())));
  });

  add_critical_message = function() {
    if (critical_message) {
      critical_message += "<br>";
    }
    return critical_message += 'critical!';
  };

  critical_hit = function(part) {
    var candidates, hit, i, slot;
    add_critical_message('critical!');
    candidates = [];
    i = 1;
    while (i <= 12) {
      slot = mech['CRIT_' + part + '_' + i];
      if (slot && !mech['destroyed_' + part + '_' + i]) {
        candidates.append({
          row: i,
          slot: slot
        });
      }
      i += 1;
    }
    if (candidates.length) {
      hit = candidates[Math.floor(Math.random() * candidates.length)];
      add_critical_message('hit ' + part + ' : ' + hit.slot);
      return _mech['destroyed_' + part + '_' + hit.i] = true;
    }
  };

  destroy = function() {
    _mech.destroyed = true;
    return alert("DESTROYED!!!");
  };

  _da_phase = {};

  damage_animation = function($part, damage, critical) {
    var $damage, loc, part;
    if (critical == null) {
      critical = '';
    }
    loc = $part.offset();
    $('body').append($damage = $("<div class='damage-alert'><div class='num'>" + damage + "</div><div class='crit'>" + critical + "</div></div!>"));
    part = $part.get(0).className;
    if (_da_phase[part] == null) {
      _da_phase[part] = 0;
    }
    _da_phase[part] += 2;
    $damage.css({
      left: loc.left + Math.sin(_da_phase[part]) * 15,
      top: loc.top + Math.cos(_da_phase[part]) * 15
    });
    return setTimeout(function() {
      return $damage.remove();
    }, 3000);
  };

  critical_message = '';

  damage_to = function(part, damage, force_critical) {
    var $part, armor, flows_to, orig_structure, roll, structure;
    if (force_critical == null) {
      force_critical = false;
    }
    $part = $('.' + part);
    critical_message = '';
    armor = _mech['armor_' + part];
    orig_structure = structure = _mech['structure_' + part];
    if (force_critical) {
      critical_hit(part);
    }
    armor -= damage;
    if (armor < 0) {
      part = part.replace('_REAR', '');
      $part = $('.' + part);
      structure = _mech['structure_' + part];
      if (structure) {
        roll = d6() + d6();
        console.log('critical roll', roll);
        if (roll >= 8 && roll <= 9) {
          critical_hit(part);
        }
        if (roll >= 10 && roll <= 11) {
          critical_hit(part);
          critical_hit(part);
        }
        if (roll === 12) {
          if (part === "HEAD") {
            return destroy();
          } else if (part.indexOf("ARM") > -1 || part.indexOf('LEG') > -1) {
            add_critical_message(part + ' blown off!');
            structure = 0;
          } else {
            critical_hit(part);
            critical_hit(part);
            critical_hit(part);
          }
        }
      }
      structure += armor;
      armor = 0;
      if (structure < 1) {
        flows_to = PARTS[part].flows_to;
        if (flows_to === "DEATH") {
          destroy();
        } else {
          if (structure < 0) {
            if (orig_structure > 0) {
              console.log(part, 'blown off!');
            }
            damage_to(flows_to, -structure);
          }
          structure = 0;
        }
      }
    }
    damage_animation($part, damage, critical_message);
    _mech['structure_' + part] = structure;
    return _mech['armor_' + part] = armor;
  };

  $('.fire').click(function() {
    var $weapons;
    $weapons = $('.count').filter(function() {
      return parseInt($(this).text()) > 0;
    }).parent();
    $weapons.each(function(weapon) {
      var apply_damage, count, idx, m, missile_type, qty, roll, side, weapon_name, _results;
      count = parseInt($(this).find('.count').text());
      _results = [];
      while (count) {
        weapon_name = $(this).find('.name').text();
        apply_damage = function(dmg) {
          var location, roll;
          if (weapon_name === 'Punch' || weapon_name === "Hatchet") {
            roll = d6();
            location = PUNCH_HIT_LOCATION[side][roll + ''];
          } else if (weapon_name === 'Kick') {
            roll = d6();
            location = KICK_HIT_LOCATION[side][roll + ''];
          } else {
            roll = d6() + d6();
            location = RANGED_HIT_LOCATION[side][roll + ''];
          }
          return damage_to(location, dmg, roll === 2);
        };
        m = weapon_name.match(/(\S+)\s(\d+)/);
        if (m) {
          qty = m[2];
          missile_type = m[1];
          roll = d6() + d6();
          qty = MISSILE_HITS_TABLE[roll][MISSILE_HITS_COLUMNS[qty]];
        } else {
          qty = 1;
          missile_type = null;
        }
        count -= 1;
        side = $('.sides .active').text();
        if (missile_type === 'SRM') {
          idx = qty;
          _results.push((function() {
            var _results1;
            _results1 = [];
            while (idx) {
              apply_damage(2);
              _results1.push(idx -= 1);
            }
            return _results1;
          })());
        } else if (missile_type === 'LRM') {
          idx = qty;
          _results.push((function() {
            var _results1;
            _results1 = [];
            while (idx > 0) {
              apply_damage(Math.min(5, idx));
              _results1.push(idx -= 5);
            }
            return _results1;
          })());
        } else {
          _results.push(apply_damage(parseInt($(this).find('.damage').text() || $(this).find('[name="damage"]').val())));
        }
      }
      return _results;
    });
    $('.count').text(0);
    return drawMech();
  });

  active_player = void 0;

  active_mech = void 0;

  _mech = void 0;

  $(function() {
    var mech, title;
    for (title in MECHS) {
      mech = MECHS[title];
      $('select').append("<option value='" + mech.name + "'>" + mech.name + "</option>");
    }
    drawWeapons();
    _mech = new MECHS.VulcanVL2T;
    return routie({
      ':player': function(player) {
        active_player = _.findWhere(players, {
          name: player
        });
        drawPlayers();
        drawPlayerForces();
        return $('.parts').hide();
      },
      ':player/:mech': function(player, mech) {
        active_player = _.findWhere(players, {
          name: player
        });
        active_mech = _.findWhere(active_player.mechs, {
          name: mech
        });
        drawPlayers();
        drawPlayerForces();
        drawMech();
        return $('[data-name="' + active_mech.name + '"]').addClass('active');
      }
    });
  });

}).call(this);
